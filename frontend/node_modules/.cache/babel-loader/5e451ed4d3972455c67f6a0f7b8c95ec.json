{"ast":null,"code":"'use strict';\n\nconst EE = require('events');\n\nconst Yallist = require('yallist');\n\nconst EOF = Symbol('EOF');\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nconst EMITTED_END = Symbol('emittedEnd');\nconst CLOSED = Symbol('closed');\nconst READ = Symbol('read');\nconst FLUSH = Symbol('flush');\nconst doIter = process.env._MP_NO_ITERATOR_SYMBOLS_ !== '1';\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol('asyncIterator not implemented');\nconst ITERATOR = doIter && Symbol.iterator || Symbol('iterator not implemented');\nconst FLUSHCHUNK = Symbol('flushChunk');\n\nconst SD = require('string_decoder').StringDecoder;\n\nconst ENCODING = Symbol('encoding');\nconst DECODER = Symbol('decoder');\nconst FLOWING = Symbol('flowing');\nconst RESUME = Symbol('resume');\nconst BUFFERLENGTH = Symbol('bufferLength');\nconst BUFFERPUSH = Symbol('bufferPush');\nconst BUFFERSHIFT = Symbol('bufferShift');\nconst OBJECTMODE = Symbol('objectMode'); // Buffer in node 4.x < 4.5.0 doesn't have working Buffer.from\n// or Buffer.alloc, and Buffer in node 10 deprecated the ctor.\n// .M, this is fine .\\^/M..\n\nlet B = Buffer;\n/* istanbul ignore next */\n\nif (!B.alloc) {\n  B = require('safe-buffer').Buffer;\n}\n\nmodule.exports = class MiniPass extends EE {\n  constructor(options) {\n    super();\n    this[FLOWING] = false;\n    this.pipes = new Yallist();\n    this.buffer = new Yallist();\n    this[OBJECTMODE] = options && options.objectMode || false;\n    if (this[OBJECTMODE]) this[ENCODING] = null;else this[ENCODING] = options && options.encoding || null;\n    if (this[ENCODING] === 'buffer') this[ENCODING] = null;\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;\n    this[EOF] = false;\n    this[EMITTED_END] = false;\n    this[CLOSED] = false;\n    this.writable = true;\n    this.readable = true;\n    this[BUFFERLENGTH] = 0;\n  }\n\n  get bufferLength() {\n    return this[BUFFERLENGTH];\n  }\n\n  get encoding() {\n    return this[ENCODING];\n  }\n\n  set encoding(enc) {\n    if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode');\n    if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH])) throw new Error('cannot change encoding');\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null;\n      if (this.buffer.length) this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk));\n    }\n\n    this[ENCODING] = enc;\n  }\n\n  setEncoding(enc) {\n    this.encoding = enc;\n  }\n\n  write(chunk, encoding, cb) {\n    if (this[EOF]) throw new Error('write after end');\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (!encoding) encoding = 'utf8'; // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n\n    if (typeof chunk === 'string' && !this[OBJECTMODE] && // unless it is a string already ready for us to use\n    !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = B.from(chunk, encoding);\n    }\n\n    if (B.isBuffer(chunk) && this[ENCODING]) chunk = this[DECODER].write(chunk);\n\n    try {\n      return this.flowing ? (this.emit('data', chunk), this.flowing) : (this[BUFFERPUSH](chunk), false);\n    } finally {\n      this.emit('readable');\n      if (cb) cb();\n    }\n  }\n\n  read(n) {\n    try {\n      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) return null;\n      if (this[OBJECTMODE]) n = null;\n\n      if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n        if (this.encoding) this.buffer = new Yallist([Array.from(this.buffer).join('')]);else this.buffer = new Yallist([B.concat(Array.from(this.buffer), this[BUFFERLENGTH])]);\n      }\n\n      return this[READ](n || null, this.buffer.head.value);\n    } finally {\n      this[MAYBE_EMIT_END]();\n    }\n  }\n\n  [READ](n, chunk) {\n    if (n === chunk.length || n === null) this[BUFFERSHIFT]();else {\n      this.buffer.head.value = chunk.slice(n);\n      chunk = chunk.slice(0, n);\n      this[BUFFERLENGTH] -= n;\n    }\n    this.emit('data', chunk);\n    if (!this.buffer.length && !this[EOF]) this.emit('drain');\n    return chunk;\n  }\n\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') cb = chunk, chunk = null;\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (chunk) this.write(chunk, encoding);\n    if (cb) this.once('end', cb);\n    this[EOF] = true;\n    this.writable = false;\n    if (this.flowing) this[MAYBE_EMIT_END]();\n  } // don't let the internal resume be overwritten\n\n\n  [RESUME]() {\n    this[FLOWING] = true;\n    this.emit('resume');\n    if (this.buffer.length) this[FLUSH]();else if (this[EOF]) this[MAYBE_EMIT_END]();else this.emit('drain');\n  }\n\n  resume() {\n    return this[RESUME]();\n  }\n\n  pause() {\n    this[FLOWING] = false;\n  }\n\n  get flowing() {\n    return this[FLOWING];\n  }\n\n  [BUFFERPUSH](chunk) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;else this[BUFFERLENGTH] += chunk.length;\n    return this.buffer.push(chunk);\n  }\n\n  [BUFFERSHIFT]() {\n    if (this.buffer.length) {\n      if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;else this[BUFFERLENGTH] -= this.buffer.head.value.length;\n    }\n\n    return this.buffer.shift();\n  }\n\n  [FLUSH]() {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));\n\n    if (!this.buffer.length && !this[EOF]) this.emit('drain');\n  }\n\n  [FLUSHCHUNK](chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false;\n  }\n\n  pipe(dest, opts) {\n    if (dest === process.stdout || dest === process.stderr) (opts = opts || {}).end = false;\n    const p = {\n      dest: dest,\n      opts: opts,\n      ondrain: _ => this[RESUME]()\n    };\n    this.pipes.push(p);\n    dest.on('drain', p.ondrain);\n    this[RESUME]();\n    return dest;\n  }\n\n  addListener(ev, fn) {\n    return this.on(ev, fn);\n  }\n\n  on(ev, fn) {\n    try {\n      return super.on(ev, fn);\n    } finally {\n      if (ev === 'data' && !this.pipes.length && !this.flowing) this[RESUME]();else if (ev === 'end' && this[EMITTED_END]) {\n        super.emit('end');\n        this.removeAllListeners('end');\n      }\n    }\n  }\n\n  get emittedEnd() {\n    return this[EMITTED_END];\n  }\n\n  [MAYBE_EMIT_END]() {\n    if (!this[EMITTED_END] && this.buffer.length === 0 && this[EOF]) {\n      this.emit('end');\n      this.emit('prefinish');\n      this.emit('finish');\n      if (this[CLOSED]) this.emit('close');\n    }\n  }\n\n  emit(ev, data) {\n    if (ev === 'data') {\n      if (!data) return;\n      if (this.pipes.length) this.pipes.forEach(p => p.dest.write(data) || this.pause());\n    } else if (ev === 'end') {\n      if (this[EMITTED_END] === true) return;\n      this[EMITTED_END] = true;\n      this.readable = false;\n\n      if (this[DECODER]) {\n        data = this[DECODER].end();\n\n        if (data) {\n          this.pipes.forEach(p => p.dest.write(data));\n          super.emit('data', data);\n        }\n      }\n\n      this.pipes.forEach(p => {\n        p.dest.removeListener('drain', p.ondrain);\n        if (!p.opts || p.opts.end !== false) p.dest.end();\n      });\n    } else if (ev === 'close') {\n      this[CLOSED] = true; // don't emit close before 'end' and 'finish'\n\n      if (!this[EMITTED_END]) return;\n    }\n\n    const args = new Array(arguments.length);\n    args[0] = ev;\n    args[1] = data;\n\n    if (arguments.length > 2) {\n      for (let i = 2; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      }\n    }\n\n    try {\n      return super.emit.apply(this, args);\n    } finally {\n      if (ev !== 'end') this[MAYBE_EMIT_END]();else this.removeAllListeners('end');\n    }\n  } // const all = await stream.collect()\n\n\n  collect() {\n    return new Promise((resolve, reject) => {\n      const buf = [];\n      this.on('data', c => buf.push(c));\n      this.on('end', () => resolve(buf));\n      this.on('error', reject);\n    });\n  } // for await (let chunk of stream)\n\n\n  [ASYNCITERATOR]() {\n    const next = () => {\n      const res = this.read();\n      if (res !== null) return Promise.resolve({\n        done: false,\n        value: res\n      });\n      if (this[EOF]) return Promise.resolve({\n        done: true\n      });\n      let resolve = null;\n      let reject = null;\n\n      const onerr = er => {\n        this.removeListener('data', ondata);\n        this.removeListener('end', onend);\n        reject(er);\n      };\n\n      const ondata = value => {\n        this.removeListener('error', onerr);\n        this.removeListener('end', onend);\n        this.pause();\n        resolve({\n          value: value,\n          done: !!this[EOF]\n        });\n      };\n\n      const onend = () => {\n        this.removeListener('error', onerr);\n        this.removeListener('data', ondata);\n        resolve({\n          done: true\n        });\n      };\n\n      return new Promise((res, rej) => {\n        reject = rej;\n        resolve = res;\n        this.once('error', onerr);\n        this.once('end', onend);\n        this.once('data', ondata);\n      });\n    };\n\n    return {\n      next\n    };\n  } // for (let chunk of stream)\n\n\n  [ITERATOR]() {\n    const next = () => {\n      const value = this.read();\n      const done = value === null;\n      return {\n        value,\n        done\n      };\n    };\n\n    return {\n      next\n    };\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}