{"ast":null,"code":"/* Generated by `npm run build`, do not edit! */\n\"use strict\";\n\nvar acorn = require(\"acorn\");\n\nif (acorn.version.indexOf(\"6.\") != 0 || acorn.version.indexOf(\"6.0.\") == 0) {\n  throw new Error(\"acorn-private-class-elements requires acorn@^6.1.0, not \" + acorn.version);\n}\n\nvar tt = acorn.tokTypes;\nvar TokenType = acorn.TokenType;\n\nmodule.exports = function (Parser) {\n  // Only load this plugin once.\n  if (Parser.prototype.parsePrivateName) {\n    return Parser;\n  } // Make sure `Parser` comes from the same acorn as our `tt`,\n  // otherwise the comparisons fail.\n\n\n  var cur = Parser;\n\n  while (cur && cur !== acorn.Parser) {\n    cur = cur.__proto__;\n  }\n\n  if (cur !== acorn.Parser) {\n    throw new Error(\"acorn-private-class-elements does not support mixing different acorn copies\");\n  }\n\n  Parser =\n  /*@__PURE__*/\n  function (Parser) {\n    function Parser_() {\n      Parser.apply(this, arguments);\n    }\n\n    if (Parser) Parser_.__proto__ = Parser;\n    Parser_.prototype = Object.create(Parser && Parser.prototype);\n    Parser_.prototype.constructor = Parser_;\n\n    Parser_.prototype._branch = function _branch() {\n      this.__branch = this.__branch || new Parser({\n        ecmaVersion: this.options.ecmaVersion\n      }, this.input);\n      this.__branch.end = this.end;\n      this.__branch.pos = this.pos;\n      this.__branch.type = this.type;\n      this.__branch.value = this.value;\n      this.__branch.containsEsc = this.containsEsc;\n      return this.__branch;\n    };\n\n    Parser_.prototype.parsePrivateClassElementName = function parsePrivateClassElementName(element) {\n      element.computed = false;\n      element.key = this.parsePrivateName();\n\n      if (element.key.name == \"constructor\") {\n        this.raise(element.key.start, \"Classes may not have a private element named constructor\");\n      }\n\n      var accept = {\n        get: \"set\",\n        set: \"get\"\n      }[element.kind];\n      var privateBoundNames = this._privateBoundNamesStack[this._privateBoundNamesStack.length - 1];\n\n      if (Object.prototype.hasOwnProperty.call(privateBoundNames, element.key.name) && privateBoundNames[element.key.name] !== accept) {\n        this.raise(element.start, \"Duplicate private element\");\n      }\n\n      privateBoundNames[element.key.name] = element.kind || true;\n      delete this._unresolvedPrivateNamesStack[this._unresolvedPrivateNamesStack.length - 1][element.key.name];\n      return element.key;\n    };\n\n    Parser_.prototype.parsePrivateName = function parsePrivateName() {\n      var node = this.startNode();\n      node.name = this.value;\n      this.next();\n      this.finishNode(node, \"PrivateName\");\n\n      if (this.options.allowReserved == \"never\") {\n        this.checkUnreserved(node);\n      }\n\n      return node;\n    }; // Parse # token\n\n\n    Parser_.prototype.getTokenFromCode = function getTokenFromCode(code) {\n      if (code === 35) {\n        ++this.pos;\n        var word = this.readWord1();\n        return this.finishToken(this.privateNameToken, word);\n      }\n\n      return Parser.prototype.getTokenFromCode.call(this, code);\n    }; // Manage stacks and check for undeclared private names\n\n\n    Parser_.prototype.parseClass = function parseClass(node, isStatement) {\n      this._privateBoundNamesStack = this._privateBoundNamesStack || [];\n      var privateBoundNames = Object.create(this._privateBoundNamesStack[this._privateBoundNamesStack.length - 1] || null);\n\n      this._privateBoundNamesStack.push(privateBoundNames);\n\n      this._unresolvedPrivateNamesStack = this._unresolvedPrivateNamesStack || [];\n      var unresolvedPrivateNames = Object.create(null);\n\n      this._unresolvedPrivateNamesStack.push(unresolvedPrivateNames);\n\n      var _return = Parser.prototype.parseClass.call(this, node, isStatement);\n\n      this._privateBoundNamesStack.pop();\n\n      this._unresolvedPrivateNamesStack.pop();\n\n      if (!this._unresolvedPrivateNamesStack.length) {\n        var names = Object.keys(unresolvedPrivateNames);\n\n        if (names.length) {\n          names.sort(function (n1, n2) {\n            return unresolvedPrivateNames[n1] - unresolvedPrivateNames[n2];\n          });\n          this.raise(unresolvedPrivateNames[names[0]], \"Usage of undeclared private name\");\n        }\n      } else {\n        Object.assign(this._unresolvedPrivateNamesStack[this._unresolvedPrivateNamesStack.length - 1], unresolvedPrivateNames);\n      }\n\n      return _return;\n    }; // Parse private element access\n\n\n    Parser_.prototype.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow) {\n      if (!this.eat(tt.dot)) {\n        return Parser.prototype.parseSubscript.call(this, base, startPos, startLoc, noCalls, maybeAsyncArrow);\n      }\n\n      var node = this.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.computed = false;\n\n      if (this.type == this.privateNameToken) {\n        node.property = this.parsePrivateName();\n\n        if (!this._privateBoundNamesStack.length || !this._privateBoundNamesStack[this._privateBoundNamesStack.length - 1][node.property.name]) {\n          this._unresolvedPrivateNamesStack[this._unresolvedPrivateNamesStack.length - 1][node.property.name] = node.property.start;\n        }\n      } else {\n        node.property = this.parseIdent(true);\n      }\n\n      return this.finishNode(node, \"MemberExpression\");\n    }; // Prohibit delete of private class elements\n\n\n    Parser_.prototype.parseMaybeUnary = function parseMaybeUnary(refDestructuringErrors, sawUnary) {\n      var _return = Parser.prototype.parseMaybeUnary.call(this, refDestructuringErrors, sawUnary);\n\n      if (_return.operator == \"delete\") {\n        if (_return.argument.type == \"MemberExpression\" && _return.argument.property.type == \"PrivateName\") {\n          this.raise(_return.start, \"Private elements may not be deleted\");\n        }\n      }\n\n      return _return;\n    };\n\n    return Parser_;\n  }(Parser);\n\n  Parser.prototype.privateNameToken = new TokenType(\"privateName\");\n  return Parser;\n};","map":null,"metadata":{},"sourceType":"script"}