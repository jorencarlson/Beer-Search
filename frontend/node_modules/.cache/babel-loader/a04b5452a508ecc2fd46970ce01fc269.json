{"ast":null,"code":"/* Generated by `npm run build`, do not edit! */\n\"use strict\";\n\nvar acorn = require(\"acorn\");\n\nvar tt = acorn.tokTypes;\n\nvar privateClassElements = require(\"../private-class-elements\");\n\nfunction maybeParseFieldValue(field) {\n  if (this.eat(tt.eq)) {\n    var oldInFieldValue = this._inFieldValue;\n    this._inFieldValue = true;\n    field.value = this.parseExpression();\n    this._inFieldValue = oldInFieldValue;\n  } else {\n    field.value = null;\n  }\n}\n\nmodule.exports = function (Parser) {\n  Parser = privateClassElements(Parser);\n  return (\n    /*@__PURE__*/\n    function (Parser) {\n      function anonymous() {\n        Parser.apply(this, arguments);\n      }\n\n      if (Parser) anonymous.__proto__ = Parser;\n      anonymous.prototype = Object.create(Parser && Parser.prototype);\n      anonymous.prototype.constructor = anonymous;\n\n      anonymous.prototype.parseClassElement = function parseClassElement(_constructorAllowsSuper) {\n        if (this.options.ecmaVersion >= 8 && (this.type == tt.name || this.type == this.privateNameToken || this.type == tt.bracketL || this.type == tt.string)) {\n          var branch = this._branch();\n\n          if (branch.type == tt.bracketL) {\n            var count = 0;\n\n            do {\n              if (branch.eat(tt.bracketL)) {\n                ++count;\n              } else if (branch.eat(tt.bracketR)) {\n                --count;\n              } else {\n                branch.next();\n              }\n            } while (count > 0);\n          } else {\n            branch.next();\n          }\n\n          if (branch.type == tt.eq || branch.canInsertSemicolon() || branch.type == tt.semi) {\n            var node = this.startNode();\n\n            if (this.type == this.privateNameToken) {\n              this.parsePrivateClassElementName(node);\n            } else {\n              this.parsePropertyName(node);\n            }\n\n            if (node.key.type === \"Identifier\" && node.key.name === \"constructor\" || node.key.type === \"Literal\" && node.key.value === \"constructor\") {\n              this.raise(node.key.start, \"Classes may not have a field called constructor\");\n            }\n\n            maybeParseFieldValue.call(this, node);\n            this.finishNode(node, \"FieldDefinition\");\n            this.semicolon();\n            return node;\n          }\n        }\n\n        return Parser.prototype.parseClassElement.apply(this, arguments);\n      }; // Prohibit arguments in class field initializers\n\n\n      anonymous.prototype.parseIdent = function parseIdent(liberal, isBinding) {\n        var ident = Parser.prototype.parseIdent.call(this, liberal, isBinding);\n\n        if (this._inFieldValue && ident.name == \"arguments\") {\n          this.raise(ident.start, \"A class field initializer may not contain arguments\");\n        }\n\n        return ident;\n      };\n\n      return anonymous;\n    }(Parser)\n  );\n};","map":null,"metadata":{},"sourceType":"script"}