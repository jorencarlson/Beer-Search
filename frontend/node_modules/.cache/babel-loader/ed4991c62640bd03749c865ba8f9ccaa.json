{"ast":null,"code":"'use strict';\n\nconst assert = require('assert');\n\nconst Buffer = require('buffer').Buffer;\n\nconst realZlib = require('zlib');\n\nconst constants = exports.constants = require('./constants.js');\n\nconst MiniPass = require('minipass');\n\nconst OriginalBufferConcat = Buffer.concat;\n\nclass ZlibError extends Error {\n  constructor(msg, errno) {\n    super('zlib: ' + msg);\n    this.errno = errno;\n    this.code = codes.get(errno);\n  }\n\n  get name() {\n    return 'ZlibError';\n  }\n\n} // translation table for return codes.\n\n\nconst codes = new Map([[constants.Z_OK, 'Z_OK'], [constants.Z_STREAM_END, 'Z_STREAM_END'], [constants.Z_NEED_DICT, 'Z_NEED_DICT'], [constants.Z_ERRNO, 'Z_ERRNO'], [constants.Z_STREAM_ERROR, 'Z_STREAM_ERROR'], [constants.Z_DATA_ERROR, 'Z_DATA_ERROR'], [constants.Z_MEM_ERROR, 'Z_MEM_ERROR'], [constants.Z_BUF_ERROR, 'Z_BUF_ERROR'], [constants.Z_VERSION_ERROR, 'Z_VERSION_ERROR']]);\nconst validFlushFlags = new Set([constants.Z_NO_FLUSH, constants.Z_PARTIAL_FLUSH, constants.Z_SYNC_FLUSH, constants.Z_FULL_FLUSH, constants.Z_FINISH, constants.Z_BLOCK]);\nconst strategies = new Set([constants.Z_FILTERED, constants.Z_HUFFMAN_ONLY, constants.Z_RLE, constants.Z_FIXED, constants.Z_DEFAULT_STRATEGY]); // the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\n\nconst _opts = Symbol('opts');\n\nconst _flushFlag = Symbol('flushFlag');\n\nconst _finishFlush = Symbol('finishFlush');\n\nconst _handle = Symbol('handle');\n\nconst _onError = Symbol('onError');\n\nconst _level = Symbol('level');\n\nconst _strategy = Symbol('strategy');\n\nconst _ended = Symbol('ended');\n\nclass Zlib extends MiniPass {\n  constructor(opts, mode) {\n    super(opts);\n    this[_ended] = false;\n    this[_opts] = opts = opts || {};\n\n    if (opts.flush && !validFlushFlags.has(opts.flush)) {\n      throw new TypeError('Invalid flush flag: ' + opts.flush);\n    }\n\n    if (opts.finishFlush && !validFlushFlags.has(opts.finishFlush)) {\n      throw new TypeError('Invalid flush flag: ' + opts.finishFlush);\n    }\n\n    this[_flushFlag] = opts.flush || constants.Z_NO_FLUSH;\n    this[_finishFlush] = typeof opts.finishFlush !== 'undefined' ? opts.finishFlush : constants.Z_FINISH;\n\n    if (opts.chunkSize) {\n      if (opts.chunkSize < constants.Z_MIN_CHUNK) {\n        throw new RangeError('Invalid chunk size: ' + opts.chunkSize);\n      }\n    }\n\n    if (opts.windowBits) {\n      if (opts.windowBits < constants.Z_MIN_WINDOWBITS || opts.windowBits > constants.Z_MAX_WINDOWBITS) {\n        throw new RangeError('Invalid windowBits: ' + opts.windowBits);\n      }\n    }\n\n    if (opts.level) {\n      if (opts.level < constants.Z_MIN_LEVEL || opts.level > constants.Z_MAX_LEVEL) {\n        throw new RangeError('Invalid compression level: ' + opts.level);\n      }\n    }\n\n    if (opts.memLevel) {\n      if (opts.memLevel < constants.Z_MIN_MEMLEVEL || opts.memLevel > constants.Z_MAX_MEMLEVEL) {\n        throw new RangeError('Invalid memLevel: ' + opts.memLevel);\n      }\n    }\n\n    if (opts.strategy && !strategies.has(opts.strategy)) throw new TypeError('Invalid strategy: ' + opts.strategy);\n\n    if (opts.dictionary) {\n      if (!(opts.dictionary instanceof Buffer)) {\n        throw new TypeError('Invalid dictionary: it should be a Buffer instance');\n      }\n    }\n\n    this[_handle] = new realZlib[mode](opts);\n\n    this[_onError] = err => {\n      // there is no way to cleanly recover.\n      // continuing only obscures problems.\n      this.close();\n      const error = new ZlibError(err.message, err.errno);\n      this.emit('error', error);\n    };\n\n    this[_handle].on('error', this[_onError]);\n\n    const level = typeof opts.level === 'number' ? opts.level : constants.Z_DEFAULT_COMPRESSION;\n    var strategy = typeof opts.strategy === 'number' ? opts.strategy : constants.Z_DEFAULT_STRATEGY; // API changed in node v9\n\n    /* istanbul ignore next */\n\n    this[_level] = level;\n    this[_strategy] = strategy;\n    this.once('end', this.close);\n  }\n\n  close() {\n    if (this[_handle]) {\n      this[_handle].close();\n\n      this[_handle] = null;\n      this.emit('close');\n    }\n  }\n\n  params(level, strategy) {\n    if (!this[_handle]) throw new Error('cannot switch params when binding is closed'); // no way to test this without also not supporting params at all\n\n    /* istanbul ignore if */\n\n    if (!this[_handle].params) throw new Error('not supported in this implementation');\n\n    if (level < constants.Z_MIN_LEVEL || level > constants.Z_MAX_LEVEL) {\n      throw new RangeError('Invalid compression level: ' + level);\n    }\n\n    if (!strategies.has(strategy)) throw new TypeError('Invalid strategy: ' + strategy);\n\n    if (this[_level] !== level || this[_strategy] !== strategy) {\n      this.flush(constants.Z_SYNC_FLUSH);\n      assert(this[_handle], 'zlib binding closed'); // .params() calls .flush(), but the latter is always async in the\n      // core zlib. We override .flush() temporarily to intercept that and\n      // flush synchronously.\n\n      const origFlush = this[_handle].flush;\n\n      this[_handle].flush = (flushFlag, cb) => {\n        this[_handle].flush = origFlush;\n        this.flush(flushFlag);\n        cb();\n      };\n\n      this[_handle].params(level, strategy);\n      /* istanbul ignore else */\n\n\n      if (this[_handle]) {\n        this[_level] = level;\n        this[_strategy] = strategy;\n      }\n    }\n  }\n\n  reset() {\n    assert(this[_handle], 'zlib binding closed');\n    return this[_handle].reset();\n  }\n\n  flush(kind) {\n    if (kind === undefined) kind = constants.Z_FULL_FLUSH;\n    if (this.ended) return;\n    const flushFlag = this[_flushFlag];\n    this[_flushFlag] = kind;\n    this.write(Buffer.alloc(0));\n    this[_flushFlag] = flushFlag;\n  }\n\n  end(chunk, encoding, cb) {\n    if (chunk) this.write(chunk, encoding);\n    this.flush(this[_finishFlush]);\n    this[_ended] = true;\n    return super.end(null, null, cb);\n  }\n\n  get ended() {\n    return this[_ended];\n  }\n\n  write(chunk, encoding, cb) {\n    // process the chunk using the sync process\n    // then super.write() all the outputted chunks\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (typeof chunk === 'string') chunk = Buffer.from(chunk, encoding);\n    assert(this[_handle], 'zlib binding closed'); // _processChunk tries to .close() the native handle after it's done, so we\n    // intercept that by temporarily making it a no-op.\n\n    const nativeHandle = this[_handle]._handle;\n    const originalNativeClose = nativeHandle.close;\n\n    nativeHandle.close = () => {};\n\n    const originalClose = this[_handle].close;\n\n    this[_handle].close = () => {}; // It also calls `Buffer.concat()` at the end, which may be convenient\n    // for some, but which we are not interested in as it slows us down.\n\n\n    Buffer.concat = args => args;\n\n    let result;\n\n    try {\n      result = this[_handle]._processChunk(chunk, this[_flushFlag]);\n    } catch (err) {\n      this[_onError](err);\n    } finally {\n      Buffer.concat = OriginalBufferConcat;\n\n      if (this[_handle]) {\n        // Core zlib resets `_handle` to null after attempting to close the\n        // native handle. Our no-op handler prevented actual closure, but we\n        // need to restore the `._handle` property.\n        this[_handle]._handle = nativeHandle;\n        nativeHandle.close = originalNativeClose;\n        this[_handle].close = originalClose; // `_processChunk()` adds an 'error' listener. If we don't remove it\n        // after each call, these handlers start piling up.\n\n        this[_handle].removeAllListeners('error');\n      }\n    }\n\n    let writeReturn;\n\n    if (result) {\n      if (Array.isArray(result) && result.length > 0) {\n        // The first buffer is always `handle._outBuffer`, which would be\n        // re-used for later invocations; so, we always have to copy that one.\n        writeReturn = super.write(Buffer.from(result[0]));\n\n        for (let i = 1; i < result.length; i++) {\n          writeReturn = super.write(result[i]);\n        }\n      } else {\n        writeReturn = super.write(Buffer.from(result));\n      }\n    }\n\n    if (cb) cb();\n    return writeReturn;\n  }\n\n} // minimal 2-byte header\n\n\nclass Deflate extends Zlib {\n  constructor(opts) {\n    super(opts, 'Deflate');\n  }\n\n}\n\nclass Inflate extends Zlib {\n  constructor(opts) {\n    super(opts, 'Inflate');\n  }\n\n} // gzip - bigger header, same deflate compression\n\n\nclass Gzip extends Zlib {\n  constructor(opts) {\n    super(opts, 'Gzip');\n  }\n\n}\n\nclass Gunzip extends Zlib {\n  constructor(opts) {\n    super(opts, 'Gunzip');\n  }\n\n} // raw - no header\n\n\nclass DeflateRaw extends Zlib {\n  constructor(opts) {\n    super(opts, 'DeflateRaw');\n  }\n\n}\n\nclass InflateRaw extends Zlib {\n  constructor(opts) {\n    super(opts, 'InflateRaw');\n  }\n\n} // auto-detect header.\n\n\nclass Unzip extends Zlib {\n  constructor(opts) {\n    super(opts, 'Unzip');\n  }\n\n}\n\nexports.Deflate = Deflate;\nexports.Inflate = Inflate;\nexports.Gzip = Gzip;\nexports.Gunzip = Gunzip;\nexports.DeflateRaw = DeflateRaw;\nexports.InflateRaw = InflateRaw;\nexports.Unzip = Unzip;","map":null,"metadata":{},"sourceType":"script"}