{"ast":null,"code":"// -------------------------------------------\n// Loads resources from the /resources folder\n// -------------------------------------------\n// TODO: rename loader\nmodule.exports = function loader(ripple, {\n  dir = '.',\n  watch = isNonProd(),\n  pattern = '/**/!(*test).{css,js}',\n  autoload = 'resources',\n  autolink = '/resources/components/**/!(*test).{css,js}',\n  aliases = {}\n} = {}) {\n  log('creating', {\n    watch\n  });\n  glob(autolink, {\n    root: dir\n  }).map(path => ripple.link(rel(dir, path), rtype(ripple, path).shortname(path)));\n\n  const _require = require('minimist')(process.argv.slice(2)),\n        _require$r = _require.r,\n        r = _require$r === void 0 ? '' : _require$r,\n        _require$resdirs = _require.resdirs,\n        resdirs = _require$resdirs === void 0 ? r : _require$resdirs,\n        load = register(ripple, dir),\n        folders = resdirs.split(',').concat(resolve(dir, autoload)).filter(Boolean).map(d => resolve(d)).map(append(pattern));\n\n  ripple.watcher = chokidar.watch(folders, {\n    ignored: /\\b_/\n  }).on('error', err).on('add', load).on('change', load).on('ready', async () => {\n    if (!watch) ripple.watcher.close();\n    await Promise.all(values(ripple.resources).map(res => res.headers.loading)).catch(err);\n    def(ripple, 'ready', true);\n    ripple.emit('ready');\n  });\n\n  ripple.load = (name, alias) => {\n    if (ripple.resources[name]) return ripple.resources[name];\n    const path = bresolve(ripple.aliases.dst[name] || name, resolve(dir, 'foo')),\n          canonical = rel(dir, path);\n\n    if (alias) {\n      ripple.link(canonical, alias);\n    } else if (!ripple.aliases.dst[name] && name != canonical) {\n      ripple.link(name, canonical);\n    }\n\n    return load(path);\n  }; // TODO: move back to core as chainable \n\n\n  ripple.resource = (name, body, headers) => {\n    // is.str(body)\n    //   ? ripple.load(body, name)\n    ripple(name, body, headers);\n    return ripple;\n  };\n\n  return ripple;\n};\n\nconst register = (ripple, dir) => path => {\n  const type = rtype(ripple, path);\n  if (!exists(path)) throw new Error(\"no such resource at \".concat(path));\n  if (!type) throw new Error(\"could not understand how to load resource at \".concat(path)); // TODO: should probably let loaders do this\n\n  delete require.cache[path];\n  return type.load({\n    name: rel(dir, path),\n    headers: {\n      path\n    }\n  });\n};\n\nconst rtype = (ripple, path) => values(ripple.types).filter(d => d.ext).sort(za('ext.length')).find(({\n  ext\n}) => minimatch(basename(path), ext));\n\nconst rel = (dir, path) => './' + relative(dir, path).replace(/\\\\/g, '/');\n\nconst bresolve = (module, parent) => require('browser-resolve').sync(module, {\n  filename: parent\n});\n\nfunction isNonProd() {\n  return lo(process.env.NODE_ENV) != 'prod' && lo(process.env.NODE_ENV) != 'production';\n}\n\nconst _require2 = require('path'),\n      resolve = _require2.resolve,\n      relative = _require2.relative,\n      basename = _require2.basename,\n      exists = require('fs').existsSync,\n      glob = require('glob').sync,\n      chokidar = require('chokidar'),\n      append = require('utilise/append'),\n      values = require('utilise/values'),\n      keys = require('utilise/keys'),\n      def = require('utilise/def'),\n      key = require('utilise/key'),\n      is = require('utilise/is'),\n      lo = require('utilise/lo'),\n      by = require('utilise/by'),\n      za = require('utilise/za'),\n      log = require('utilise/log')('[ri/resdir]'),\n      err = require('utilise/err')('[ri/resdir]'),\n      minimatch = require('minimatch'),\n      extname = path => [''].concat(path.split('.').slice(1)).join('.');","map":null,"metadata":{},"sourceType":"script"}