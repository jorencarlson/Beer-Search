{"ast":null,"code":"const request = require('request-promise-native');\n\nconst uuid = require('uuid');\n\nconst _require = require('./process'),\n      getProcess = _require.getProcess,\n      killProcess = _require.killProcess,\n      setAuthtoken = _require.setAuthtoken;\n\nlet internalApi;\nlet tunnels = {};\n\nasync function connect(opts) {\n  opts = defaults(opts);\n  validate(opts);\n\n  if (opts.authtoken) {\n    await setAuthtoken(opts);\n  }\n\n  const url = await getProcess(opts);\n  internalApi = request.defaults({\n    baseUrl: url\n  });\n  return connectRetry(opts);\n}\n\nfunction defaults(opts) {\n  opts = opts || {\n    proto: 'http',\n    addr: 80\n  };\n  if (typeof opts === 'function') opts = {\n    proto: 'http',\n    addr: 80\n  };\n  if (typeof opts !== 'object') opts = {\n    proto: 'http',\n    addr: opts\n  };\n  if (!opts.proto) opts.proto = 'http';\n  if (!opts.addr) opts.addr = opts.port || opts.host || 80;\n  if (opts.httpauth) opts.auth = opts.httpauth;\n  return opts;\n}\n\nfunction validate(opts) {\n  if (opts.web_addr === false || opts.web_addr === 'false') {\n    throw new Error('web_addr:false is not supported, module depends on internal ngrok api');\n  }\n}\n\nasync function connectRetry(opts, retryCount = 0) {\n  opts.name = String(opts.name || uuid.v4());\n\n  try {\n    const response = await internalApi.post({\n      url: 'api/tunnels',\n      json: opts\n    });\n    const publicUrl = response.public_url;\n\n    if (!publicUrl) {\n      throw new Error('failed to start tunnel');\n    }\n\n    tunnels[publicUrl] = response.uri;\n\n    if (opts.proto === 'http' && opts.bind_tls !== false) {\n      tunnels[publicUrl.replace('https', 'http')] = response.uri + ' (http)';\n    }\n\n    return publicUrl;\n  } catch (err) {\n    if (!isRetriable(err) || retryCount >= 100) {\n      throw err.error || err.response;\n    }\n\n    await new Promise(resolve => setTimeout(resolve, 200));\n    return connectRetry(opts, ++retryCount);\n  }\n}\n\nfunction isRetriable(err) {\n  if (!err.response) return false;\n  const body = err.response.body;\n  const notReady500 = err.statusCode === 500 && /panic/.test(body);\n  const notReady502 = err.statusCode === 502 && body.details && body.details.err === 'tunnel session not ready yet';\n  return notReady500 || notReady502;\n}\n\nasync function disconnect(publicUrl) {\n  if (!internalApi) return;\n\n  if (!publicUrl) {\n    const disconnectAll = Object.keys(tunnels).map(disconnect);\n    return Promise.all(disconnectAll);\n  }\n\n  const tunnelUrl = tunnels[publicUrl];\n\n  if (!tunnelUrl) {\n    throw new Error(\"there is no tunnel with url: \".concat(publicUrl));\n  }\n\n  await internalApi.del(tunnelUrl);\n  delete tunnels[publicUrl];\n}\n\nasync function kill() {\n  if (!internalApi) return;\n  await killProcess();\n  internalApi = null;\n  tunnels = {};\n}\n\nfunction getApi() {\n  return internalApi;\n}\n\nmodule.exports = {\n  connect,\n  disconnect,\n  authtoken: setAuthtoken,\n  kill,\n  getApi\n};","map":null,"metadata":{},"sourceType":"script"}