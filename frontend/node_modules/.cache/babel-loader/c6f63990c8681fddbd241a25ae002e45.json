{"ast":null,"code":"const _require = require('child_process'),\n      spawn = _require.spawn;\n\nconst platform = require('os').platform();\n\nconst defaultDir = __dirname + '/bin';\nconst bin = './ngrok' + (platform === 'win32' ? '.exe' : '');\nconst ready = /starting web service.*addr=(\\d+\\.\\d+\\.\\d+\\.\\d+:\\d+)/;\nconst inUse = /address already in use/;\nlet processPromise, activeProcess;\n/*\n\tngrok process runs internal ngrok api\n\tand should be spawned only ONCE \n\t(respawn allowed if it fails or .kill method called)\n*/\n\nasync function getProcess(opts) {\n  if (processPromise) return processPromise;\n\n  try {\n    processPromise = startProcess(opts);\n    return await processPromise;\n  } catch (ex) {\n    processPromise = null;\n    throw ex;\n  }\n}\n\nasync function startProcess(opts) {\n  let dir = defaultDir;\n  const start = ['start', '--none', '--log=stdout'];\n  if (opts.region) start.push('--region=' + opts.region);\n  if (opts.configPath) start.push('--config=' + opts.configPath);\n  if (opts.binPath) dir = opts.binPath(dir);\n  const ngrok = spawn(bin, start, {\n    cwd: dir\n  });\n  let resolve, reject;\n  const apiUrl = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  ngrok.stdout.on('data', data => {\n    const msg = data.toString();\n    const addr = msg.match(ready);\n\n    if (addr) {\n      resolve(\"http://\".concat(addr[1]));\n    } else if (msg.match(inUse)) {\n      reject(new Error(msg.substring(0, 10000)));\n    }\n  });\n  ngrok.stderr.on('data', data => {\n    const msg = data.toString().substring(0, 10000);\n    reject(new Error(msg));\n  });\n  ngrok.on('exit', () => {\n    processPromise = null;\n    activeProcess = null;\n  });\n  process.on('exit', async () => await killProcess());\n\n  try {\n    const url = await apiUrl;\n    activeProcess = ngrok;\n    return url;\n  } catch (ex) {\n    ngrok.kill();\n    throw ex;\n  } finally {\n    ngrok.stdout.removeAllListeners('data');\n    ngrok.stderr.removeAllListeners('data');\n  }\n}\n\nfunction killProcess() {\n  if (!activeProcess) return;\n  return new Promise(resolve => {\n    activeProcess.on('exit', () => resolve());\n    activeProcess.kill();\n  });\n}\n/**\n * @param {string | INgrokOptions} optsOrToken\n */\n\n\nasync function setAuthtoken(optsOrToken) {\n  const isOpts = typeof optsOrToken !== 'string';\n  const opts = isOpts ? optsOrToken : {};\n  const token = isOpts ? opts.authtoken : optsOrToken;\n  const authtoken = ['authtoken', token];\n  if (opts.configPath) authtoken.push('--config=' + opts.configPath);\n  let dir = defaultDir;\n  if (opts.binPath) dir = opts.binPath(dir);\n  const ngrok = spawn(bin, authtoken, {\n    cwd: dir\n  });\n  const killed = new Promise((resolve, reject) => {\n    ngrok.stdout.once('data', () => resolve());\n    ngrok.stderr.once('data', () => reject(new Error('cant set authtoken')));\n  });\n\n  try {\n    return await killed;\n  } finally {\n    ngrok.kill();\n  }\n}\n\nmodule.exports = {\n  getProcess,\n  killProcess,\n  setAuthtoken\n};","map":null,"metadata":{},"sourceType":"script"}