{"ast":null,"code":"module.exports = function popper({\n  tests = 'browserify test.js',\n  farm = 'browserstack',\n  notunnel = false,\n  runner = 'mocha',\n  browsers = [],\n  globals = '',\n  port = 1945,\n  watch = '.',\n  opts = {},\n  timeout,\n  ripple\n} = {}) {\n  // defaults\n  const wait = debounce(timeout = timeout || +env.POPPER_TIMEOUT || 20000)(quit),\n        maxRetries = 3;\n  ripple = (ripple || rijs)(extend({\n    dir,\n    port\n  })(opts));\n  resdir(ripple, dir);\n  browsers = browsers.map(canonical(farm)).filter(Boolean); // define data resources\n\n  ripple('results', {}, {\n    from\n  });\n  ripple('totals', {}); // watch files\n\n  if (!isCI && watch) {\n    log('watching', watch);\n    chokidar.watch(watch, {\n      ignored: [/^\\.(.*)[^\\/\\\\]/, /[\\/\\\\]\\./, /node_modules(.+)popper/],\n      ignoreInitial: true,\n      usePolling: false,\n      depth: 5\n    }).on('change', debounce(generate));\n  } // icons\n\n\n  ripple(require('browser-icons')); // limit dashboard resources\n\n  ripple.to = limit(ripple.to); // proxy errors and register agent details\n\n  ripple.server.on('connected', connected); // serve assets\n\n  ripple.server.express.use(compression()).use('/utilise.min.js', send(local('utilise', 'utilise.min.js'))).use('/utilise.js', send(local('utilise', 'utilise.js'))).use('/mocha.css', send(local('mocha', 'mocha.css'))).use('/mocha.js', send(local('mocha', 'mocha.js'))).use('/chai.js', send(local('chai', 'chai.js'))).use('/dashboard/:id', send(local(\"./client/\".concat(runner, \"/logs.html\")))).use('/dashboard', send(local('./client/dashboard.html'))).use('/', serve(local('./client'))).use('/', index());\n  return generate(), spawn(), ripple;\n\n  function index() {\n    const head = is.arr(globals) ? globals.join('\\n') : globals,\n          html = file(local(\"./client/\".concat(runner, \"/index.html\"))).replace('<!-- { extra scripts } -->', head || '');\n    return (req, res) => res.send(html);\n  }\n\n  function generate() {\n    log('generating tests');\n    const bundle = write(local('./client/tests.js')),\n          stream = is.fn(tests) ? tests() : run('sh', ['-c', tests], {\n      stdio: 'pipe'\n    });\n    if (stream.stderr) stream.stderr.pipe(process.stderr);\n    ((stream.stdout || stream).on('end', debounce(500)(reload)).pipe(bundle).flow || noop)();\n  }\n\n  function from(req) {\n    return req.data.type == 'RERUN' ? reload(req.data.value) : req.data.type == 'SAVE' ? save(req.socket.platform, req.data.value) : false;\n  }\n\n  function save(platform, result) {\n    const uid = platform.uid,\n          results = ripple('results'),\n          retries = uid in results ? results[uid].retries : 0;\n    log('received result from', uid);\n    result.platform = platform;\n    result.retries = retries;\n    update(uid, result)(ripple('results'));\n    totals();\n    ci(result);\n  }\n\n  function ci(r) {\n    if (!isCI || r.stats.running) return;\n    const browser = browsers.filter(d => {\n      if (d._name && d._name !== r.platform.name) return false;\n      if (d._version && d._version !== r.platform.version) return false;\n      if (d._os && d._os !== r.platform.os.name) return false;\n      if (d._os_version && d._os_version !== r.platform.os.version) return false;\n      return true;\n    }).pop();\n    if (!browser) return log('result not in matrix'.red, r.platform.uid);\n    browser.passed_by = r.platform.uid;\n    browser.passed = !r.stats.failures;\n    browser.passed ? log('browser passed:', r.platform.uid.green.bold) : err('browser failed:', r.platform.uid.red.bold);\n    if (!browser.passed && r.retries < maxRetries) return log('retrying'.yellow, r.platform.uid, ++r.retries, '/', str(maxRetries).grey), reload(r.platform.uid);\n    if (farms[farm].status) farms[farm].status(browser, r.platform);\n    const target = browsers.length,\n          passed = browsers.filter(by('passed')).length,\n          finished = browsers.filter(by('passed_by')).length;\n    log('ci targets', str(passed).green.bold, '/', str(target).grey);\n    target === passed ? time(3000, d => process.exit(0)) : target === finished ? time(3000, d => !env.POPPER_TIMEOUT && process.exit(1)) : wait();\n  }\n\n  function connected(socket) {\n    socket.platform = parse(socket);\n    socket.type = socket.handshake.url == '/dashboard' ? 'dashboard' : 'agent';\n    log('connected', socket.platform.uid.green, socket.type.grey);\n    socket.on('global err', (message, url, linenumber) => err('Global error: ', socket.platform.uid.bold, message, url, linenumber));\n    if (debug) socket.on('console', function () {\n      log(socket.platform.uid.bold, 'says:', '', arguments[0], to.arr(arguments[1]).map(str).join(' '));\n    });\n  }\n\n  function quit() {\n    log('no updates received for', timeout / 1000, 'seconds. timing out..');\n    process.exit(1);\n  }\n\n  function reload(uid) {\n    const uids = uid ? [uid] : ripple.server.ws.sockets.map(d => d.platform.uid);\n    uids.map(uid => update(\"\".concat(uid, \".stats.running\"), true)(ripple('results')));\n    const agents = ripple.server.ws.sockets.filter(not(by('handshake.url', '/dashboard'))).filter(by('platform.uid', is.in(uids))).map(emitReload).length;\n    log('reloading', str(agents).cyan, 'agents', uid || '');\n  }\n\n  function totals() {\n    const res = values(ripple('results'));\n    return ripple('totals', {\n      tests: str(res.map(key('stats.tests')).filter(Boolean).pop() || '?'),\n      browsers: str(res.length),\n      passing: str(res.map(key('stats.failures')).filter(is(0)).length || '0')\n    });\n  }\n\n  function spawn() {\n    ripple.server.once('listening').then(() => {\n      log('running on port', ripple.server.http.address().port);\n      !notunnel && require('ngrok').connect(ripple.server.http.address().port, (e, url) => {\n        log('tunnelling', url && url.magenta);\n        return e ? err('error setting up reverse tunnel', e.stack) : browsers.map(boot(farm)(url));\n      });\n    });\n  }\n};\n\nconst _require = require('utilise/pure'),\n      values = _require.values,\n      key = _require.key,\n      str = _require.str,\n      not = _require.not,\n      by = _require.by,\n      grep = _require.grep,\n      lo = _require.lo,\n      is = _require.is,\n      debounce = _require.debounce,\n      extend = _require.extend,\n      falsy = _require.falsy,\n      send = _require.send,\n      file = _require.file,\n      noop = _require.noop,\n      update = _require.update,\n      identity = _require.identity,\n      time = _require.time,\n      includes = _require.includes,\n      write = require('fs').createWriteStream,\n      run = require('child_process').spawn,\n      _require2 = require('cryonic'),\n      stringify = _require2.stringify,\n      _require3 = require('path'),\n      resolve = _require3.resolve,\n      compression = require('compression'),\n      browserify = require('browserify'),\n      platform = require('platform'),\n      chokidar = require('chokidar'),\n      express = require('express'),\n      resdir = require('rijs.resdir'),\n      serve = require('serve-static'),\n      farms = require('./farms'),\n      wd = require('wd'),\n      rijs = opts => require('rijs.npm')(require('rijs')(opts));\n\nconst log = require('utilise/log')('[popper]'),\n      err = require('utilise/err')('[popper]'),\n      old = grep(console, 'log', /^(?!.*\\[ri\\/)/),\n      env = process.env,\n      dir = __dirname,\n      isCI = env.CI === 'true',\n      debug = lo(env.NODE_ENV) == 'debug';\n\nconst heartbeat = vm => setInterval(d => vm.eval('', e => {\n  if (e) console.error(e);\n}), 30000);\n\nconst canonical = farm => browser => is.str(browser) ? farms[farm].browsers[browser] : browser;\n\nconst local = (module, file) => {\n  const base = !file ? __dirname : require.resolve(module),\n        read = !file ? module : '../' + file;\n  return resolve(base, read);\n};\n\nconst emitReload = socket => socket.send(stringify({\n  data: {\n    exec: () => location.reload()\n  }\n}));\n\nconst parse = socket => {\n  const ua = socket.handshake.headers['user-agent'],\n        p = platform.parse(ua),\n        o = {\n    name: lo(p.name),\n    version: major(p.version),\n    os: {\n      name: lo(p.os.family.split(' ').shift()),\n      version: major(p.os.version, p.os.family)\n    }\n  };\n  if (o.os.name == 'os') o.os.name = 'osx';\n  if (o.name == 'chrome mobile') o.name = 'chrome';\n  if (o.name == 'microsoft edge') o.name = 'ie';\n  const uid = o.name + '-' + o.version + '-' + o.os.name + '-' + o.os.version;\n  o.uid = uid;\n  return o;\n};\n\nconst major = (v, f) => v ? v.split('.').shift() : includes('xp')(lo(f)) ? 'xp' : '?';\n\nconst limit = next => (req, socket) => {\n  return socket.handshake.url == '/dashboard' ? next(req, socket) : false;\n};\n\nconst boot = farm => url => opts => {\n  const _opts$_name = opts._name,\n        _name = _opts$_name === void 0 ? '?' : _opts$_name,\n        _opts$_version = opts._version,\n        _version = _opts$_version === void 0 ? '?' : _opts$_version,\n        _opts$_os = opts._os,\n        _os = _opts$_os === void 0 ? '?' : _opts$_os,\n        _farms$farm = farms[farm],\n        connect = _farms$farm.connect,\n        _farms$farm$parse = _farms$farm.parse,\n        parse = _farms$farm$parse === void 0 ? identity : _farms$farm$parse,\n        id = \"\".concat(_name.cyan, \" \").concat(_version.cyan, \" on \").concat(_os),\n        vm = opts.vm = connect(wd);\n\n  if (!vm) err('failed to connect to ' + farm), process.exit(1);\n  log(\"booting up \".concat(id));\n  vm.init(parse(opts), e => {\n    if (e) return err(e, id);\n    log('initialised', id);\n    vm.get(url, e => {\n      if (e) return err(e, id);\n      log('opened to test page', id.cyan);\n      heartbeat(vm);\n    });\n  });\n};","map":null,"metadata":{},"sourceType":"script"}