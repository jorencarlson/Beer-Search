{"ast":null,"code":"/* Generated by `npm run build`, do not edit! */\n\"use strict\";\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\nvar acorn = require(\"acorn\");\n\nvar tt = acorn.tokTypes;\n\nfunction maybeParseFieldValue(field) {\n  if (this.eat(tt.eq)) {\n    var oldInFieldValue = this._inStaticFieldValue;\n    this._inStaticFieldValue = true;\n    field.value = this.parseExpression();\n    this._inStaticFieldValue = oldInFieldValue;\n  } else {\n    field.value = null;\n  }\n}\n\nvar privateClassElements = require(\"../private-class-elements\");\n\nmodule.exports = function (Parser) {\n  var ExtendedParser = privateClassElements(Parser);\n  return (\n    /*@__PURE__*/\n    function (ExtendedParser) {\n      function anonymous() {\n        ExtendedParser.apply(this, arguments);\n      }\n\n      if (ExtendedParser) anonymous.__proto__ = ExtendedParser;\n      anonymous.prototype = Object.create(ExtendedParser && ExtendedParser.prototype);\n      anonymous.prototype.constructor = anonymous;\n\n      anonymous.prototype.parseClassElement = function parseClassElement(_constructorAllowsSuper) {\n        var this$1 = this;\n\n        if (this.eat(tt.semi)) {\n          return null;\n        }\n\n        var node = this.startNode();\n\n        var tryContextual = function (k, noLineBreak) {\n          if (typeof noLineBreak == \"undefined\") {\n            noLineBreak = false;\n          }\n\n          var start = this$1.start,\n              startLoc = this$1.startLoc;\n\n          if (!this$1.eatContextual(k)) {\n            return false;\n          }\n\n          if (this$1.type !== tt.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) {\n            return true;\n          }\n\n          if (node.key) {\n            this$1.unexpected();\n          }\n\n          node.computed = false;\n          node.key = this$1.startNodeAt(start, startLoc);\n          node.key.name = k;\n          this$1.finishNode(node.key, \"Identifier\");\n          return false;\n        };\n\n        node.static = tryContextual(\"static\");\n\n        if (!node.static) {\n          return ExtendedParser.prototype.parseClassElement.apply(this, arguments);\n        }\n\n        var isGenerator = this.eat(tt.star);\n        var isAsync = false;\n\n        if (!isGenerator) {\n          // Special-case for `async`, since `parseClassMember` currently looks\n          // for `(` to determine whether `async` is a method name\n          if (this.options.ecmaVersion >= 8 && this.isContextual(\"async\")) {\n            skipWhiteSpace.lastIndex = this.pos;\n            var skip = skipWhiteSpace.exec(this.input);\n            var next = this.input.charAt(this.pos + skip[0].length);\n\n            if (next === \";\" || next === \"=\") {\n              node.key = this.parseIdent(true);\n              node.computed = false;\n              maybeParseFieldValue.call(this, node);\n              this.finishNode(node, \"FieldDefinition\");\n              this.semicolon();\n              return node;\n            } else if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\n              isAsync = true;\n              isGenerator = this.options.ecmaVersion >= 9 && this.eat(tt.star);\n            }\n          } else if (tryContextual(\"get\")) {\n            node.kind = \"get\";\n          } else if (tryContextual(\"set\")) {\n            node.kind = \"set\";\n          }\n        }\n\n        if (this.type === this.privateNameToken) {\n          this.parsePrivateClassElementName(node);\n\n          if (this.type !== tt.parenL) {\n            if (node.key.name === \"prototype\") {\n              this.raise(node.key.start, \"Classes may not have a private static property named prototype\");\n            }\n\n            maybeParseFieldValue.call(this, node);\n            this.finishNode(node, \"FieldDefinition\");\n            this.semicolon();\n            return node;\n          }\n        } else if (!node.key) {\n          this.parsePropertyName(node);\n\n          if ((node.key.name || node.key.value) === \"prototype\" && !node.computed) {\n            this.raise(node.key.start, \"Classes may not have a static property named prototype\");\n          }\n        }\n\n        if (!node.kind) {\n          node.kind = \"method\";\n        }\n\n        this.parseClassMethod(node, isGenerator, isAsync);\n\n        if (!node.kind && (node.key.name || node.key.value) === \"constructor\" && !node.computed) {\n          this.raise(node.key.start, \"Classes may not have a static field named constructor\");\n        }\n\n        if (node.kind === \"get\" && node.value.params.length !== 0) {\n          this.raiseRecoverable(node.value.start, \"getter should have no params\");\n        }\n\n        if (node.kind === \"set\" && node.value.params.length !== 1) {\n          this.raiseRecoverable(node.value.start, \"setter should have exactly one param\");\n        }\n\n        if (node.kind === \"set\" && node.value.params[0].type === \"RestElement\") {\n          this.raiseRecoverable(node.value.params[0].start, \"Setter cannot use rest params\");\n        }\n\n        return node;\n      }; // Parse public static fields\n\n\n      anonymous.prototype.parseClassMethod = function parseClassMethod(method, isGenerator, isAsync, _allowsDirectSuper) {\n        if (isGenerator || isAsync || method.kind != \"method\" || !method.static || this.options.ecmaVersion < 8 || this.type == tt.parenL) {\n          return ExtendedParser.prototype.parseClassMethod.apply(this, arguments);\n        }\n\n        maybeParseFieldValue.call(this, method);\n        delete method.kind;\n        method = this.finishNode(method, \"FieldDefinition\");\n        this.semicolon();\n        return method;\n      }; // Prohibit arguments in class field initializers\n\n\n      anonymous.prototype.parseIdent = function parseIdent(liberal, isBinding) {\n        var ident = ExtendedParser.prototype.parseIdent.call(this, liberal, isBinding);\n\n        if (this._inStaticFieldValue && ident.name == \"arguments\") {\n          this.raise(ident.start, \"A static class field initializer may not contain arguments\");\n        }\n\n        return ident;\n      };\n\n      return anonymous;\n    }(ExtendedParser)\n  );\n};","map":null,"metadata":{},"sourceType":"script"}